[TOC]

### 状态解释

#### 无状态

无状态进程或应用可以理解为孤立的。关于它的既往事务，我们一无所知，没有任何参考。每项事务处理似乎都是从头开始。无状态应用只提供一项服务或功能，并使用内容交付网络（CDN）、Web 或打印服务器来处理这些短期请求。 

无状态事务的典型示例是执行在线搜索，寻找您想要的答案。您在搜索引擎中输入问题，然后按 Enter。如果您的事务被意外中断或关闭，则只需重新开始即可。我们不妨将无状态事务看作一台自动售货机：一个请求对应一个响应。 

#### 有状态

有状态应用和流程则是可以周而复始、反复发生的应用和流程，例如网上银行或电子邮件。这些操作是在先前的事务背景下执行的，当前事务可能会受到先前事务的影响。正因如此，有状态应用在每次处理用户的请求时都会使用相同的服务器。 

如果有状态事务被中断，其上下文和历史记录会被存储下来，这样就可以或多或少地从上次中断的地方继续。有状态应用会跟踪诸如窗口位置、设置首选项和近期活动等内容。我们可以把有状态事务视为与同一个人进行的定期对话。

我们日常使用的大多数应用都是有状态的，但随着技术的进步，微服务和容器使得在云端构建和部署应用变得更加容易。 

##### 腾讯云作者解释

https://cloud.tencent.com/developer/article/1620559

![img](https://ask.qcloudimg.com/http-save/7234372/knzhodgxbh.png?imageView2/2/w/1620)

比如，你将常温的水，通过“倒入水壶”、“通电加热”等工作后变成了100度的水，就是这样一个过程。

正如烧水的例子，大多数时候得到一个“成果”往往需要好几道“行动”才能完成![img](https://ask.qcloudimg.com/http-save/7234372/564obsca77.png?imageView2/2/w/1620)

这个时候如果想降低这几道“行动”总的成本（如：时间）该怎么办呢？

自然就是提炼出反复要做的事情，让其只做一次。而这个事情在程序中，就是将一部分“数据”放到一个「**暂存区**」（一般就是本地内存），以提供给相关的“行动”共用。![img](https://ask.qcloudimg.com/http-save/7234372/xy5hp32gin.png?imageView2/2/w/1620)

但是如此一来，就导致了需要增加一道关系，以表示每一个“行动”与哪一个「暂存区」关联。因为在程序里，“行动”可能是「多线程」的。

这时，这个“行动”就变成「有状态」的了。![img](https://ask.qcloudimg.com/http-save/7234372/wpnz6oz896.png?imageView2/2/w/1620)

> 注：共用同一个「暂存区」的多个“行动”所处的环境经常被称作「上下文」。

我们再来深入聊聊「有状态」。
「暂存区」里存的是「数据」，所以可以理解为“有数据”就等价于“有状态”。「数据」在程序中的作用范围分为「局部」和「全局」（对应局部变量和全局变量），因此**「状态」其实也可以分为两种，一种是局部的「会话状态」，一种是全局的「资源状态」**。

> 题外话：因为有些服务端不单单负责运算，还会提供其自身范围内的「数据」出去，这些「数据」属于服务端完整的一部分，被称作「资源」。所以，理论上「资源」可以被每个「会话」来使用，因此是全局的状态。

与「有状态」相反的是「无状态」，**「无状态」意味着每次“加工”的所需的“原料”全部由外界提供，服务端内部不做任何的「暂存区」。并且请求可以提交到服务端的任意副本节点上，处理结果都是完全一样的**。

有一类方法天生是「无状态」，就是负责表达移动和组合的“算法”。因为它的本质就是：

1.  接收“原料”（入参）
2. “加工”并返回“成果”（出参）

### RESTful API

只要符合RESTful系统的6个导向性约束，就算做RESTful API：

- **客户端/服务器架构：**REST 架构由客户端、服务器和资源构成，通过 HTTP 来处理请求。
- **无状态：**请求所经过的服务器上不会存储任何客户端内容。与会话状态相关的信息会存储在客户端上。
- **可缓存性：**通过缓存，可免去客户端与服务器之间的某些交互。
- **分层系统：**客户端与服务器之间的交互可以通过额外的层来进行调解。这些层可以提供额外的功能，如负载均衡、共享缓存或安全防护。
- **按需代码（可选）：**服务器可通过传输可执行代码来扩展客户端的功能。
- **统一接口：**这项约束是 RESTful API 的设计核心，共涵盖 4 个层面：
  - **识别请求中的资源：**请求中的资源会被识别，并与返回给客户端的表示内容分离开来。
  - **通过不同的表示内容来操纵资源：**客户端会收到表示不同资源的文件。这些表示内容必须提供足够的信息，以便执行修改或删除操作。
  - **自描述消息：**返回给客户端的每个消息都包含充足的信息，用于指明客户端应该如何处理所收到的信息。
  - **将超媒体作为应用状态的引擎：**在访问某个资源后，REST 客户端应该能够通过超链接来发现当前可用的所有其他操作。